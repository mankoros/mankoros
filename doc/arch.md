# 架构与物理内存管理

MankorOS 使用内核态与用户态共享的页表以避免在系统调用或时钟中断时冲刷 TLB，以提高性能。

## 内存空间布局

MankorOS 的虚拟内存空间主要分为两段：用户段和内核段。
用户段位于虚拟地址空间的低地址，内核段位于虚拟地址空间的高地址。
根据 SV39 的规范，用户段 39 位以上均为 0，内核段 39 以上均为 1。
其中，内核的链接基地址为 0xFFFFFFFF80200000，在链接脚本 linker.ld 中设置

具体的内存空间布局如下表：

用户程序映像：0x0000_0000_0001_0000 ~ 0x0000_0000_4000_0000
用户堆：0x0000_0000_4000_0000 ~ 0x0000_0000_8000_0000
用户栈：0x0000_0001_0000_0000 ~ 0x0000_0002_0000_0000
用户 MMAP：0x0000_0002_0000_0000 ~ 0x0000_0004_0000_0000

内核物理内存直接映射：0xffff_fff0_0000_0000 ~ 0xffff_ffff_8000_0000
内核映像：0xffff_ffff_8000_0000 ~ 0xffff_ffff_c000_0000
硬件 MMIO：0xffff_ffff_c000_0000 ~ 0xffff_ffff_f000_0000


## 内核动态内存分配器

为了使用 Rust 中的各种动态内存结构，需要在内核中实现一个动态内存的分配器。

MankorOS 的内核动态内存分配器使用了 Buddy allocator，来自 crate `buddy_system_allocator`。

Buddy allocator 是操作系统中一种常用的物理页分配算法，它的主要原理是将可用的物理内存按照 2 的幂次方进行划分，每个划分成为一个“伙伴块”，并根据伙伴块的大小将它们组织成一棵二叉树。当需要分配一个指定大小的物理内存时，buddy allocator 首先找到最小的 2 的幂次方大小的伙伴块，然后检查该伙伴块是否已经被分配出去。如果该伙伴块已经被分配出去，则继续寻找下一个伙伴块，直到找到空闲的伙伴块。

如果找到了一个空闲的伙伴块，那么就将该伙伴块标记为已分配，并把它从可用伙伴列表中移除。接着，将该伙伴块逐级向上合并，直到合并到大于等于分配请求大小的伙伴块为止。这样，最终的合并后的伙伴块就可以满足分配请求。如果在合并过程中发现其中某个伙伴块已经被分配出去，那么就停止合并，将剩余的子伙伴块重新加入可用伙伴列表中。

当需要释放已经分配出去的物理内存时，buddy allocator 会将该内存块标记为未分配并加入可用伙伴列表中。接着，它会检查该内存块所处的伙伴块是否也是未分配状态。如果该伙伴块的另一个子伙伴块也是未分配状态，那么就将这两个伙伴块合并成一个更大的伙伴块，并继续向上检查合并后的伙伴块是否可以再次和其它空闲伙伴块合并。

这样，通过不断地进行伙伴块的合并和分裂，buddy allocator 可以高效地管理可用的物理内存，避免了内存碎片化和空间浪费，提高了内存空间利用率和系统性能。

## 物理页分配器

内核还需要管理全部的空闲物理内存，MankorOS 为此使用了 bitmap allocator，来自 rCore 的仓库 https://github.com/rcore-os/bitmap-allocator

Bitmap allocator 的主要原理是通过一个位图来管理一段连续的内存空间。这个位图中的每一位代表一块内存，如果该位为 0，说明对应的内存块空闲；如果该位为 1，说明对应的内存块已经被分配出去。

当需要分配一个指定大小的内存时，bitmap allocator 首先检查位图中是否有足够的连续空闲内存块可以满足分配请求。如果有，就将对应的位图标记为已分配，并返回该内存块的起始地址；如果没有，就返回空指针，表示分配失败。

当需要释放已经分配出去的内存时，bitmap allocator 将对应位图标记为未分配。这样，已经释放的内存块就可以被下一次分配请求使用了。

## 页表管理

### 启动阶段

简单起见，MankorOS 并没有实现内核搬运等功能，而是直接在编译时将内核直接链接到高地址空间。
这带来了一个问题，在未配置好地址翻译的时候，不能进入 Rust 执行，也就是需要在汇编语言尽快打开地址翻译。

MankorOS 设计了一个 boot 页表，嵌入在内核映像的.data 段

具体如下：

    "   .section .data
        .align 12
    _boot_page_table_sv39:
        # 0x00000000_00000000 -> 0x00000000 (1G, VRWXAD) for early console
        .quad (0x00000 << 10) | 0xcf
        .quad 0
        # 0x00000000_80000000 -> 0x80000000 (1G, VRWXAD)
        .quad (0x80000 << 10) | 0xcf
        .zero 8 * 507
        # 0xffffffff_80000000 -> 0x80000000 (1G, VRWXAD)
        .quad (0x80000 << 10) | 0xcf
        .quad 0
    "

boot 页表使用了 huge page，直接将内核映像映射到正确的高位地址


内核初始化结束后，低地址空间中的映射将被删除，留给用户空间。

<!-- TODO: 描述一下页表的数据结构 -->
<!-- TODO: 页表物理页管理 -->

## 共享物理页管理

<!-- TODO: shared_frame_mgr.rs -->